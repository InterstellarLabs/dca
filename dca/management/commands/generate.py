"""
Management command to generate crud APIs for django models
"""

# Built-in imports.
import os
import re
from ast import parse
from pathlib import Path
from inspect import getsource
from importlib import import_module
from pkg_resources import resource_filename


# Django imports.
from django.apps import apps
from django.conf import settings
from django.core.management.base import BaseCommand


# Third party imports.
from inflect import engine
from orm_choices.core import user_attributes


# App imports.
from dca.constants import DCA_SUFFIX, DCA_AST_MAP, \
    DCA_IGNORE_FIELDS, \
    DCA_REMOVE_FIELDS, DCA_DIR, \
    DCA_AUTO_FILE, DCA_CUSTOM
from dca.templates.dbapi import DCA_CRUD_TEMPLATE


plural = engine().plural
CHOICES = import_module(settings.DCA_CHOICES)


def ensure_data():
    '''
    Ensure that the dca directory and files
    '''
    if not os.path.exists(DCA_DIR):
        os.makedirs(DCA_DIR)
    Path(f'{DCA_DIR}/__init__.py').touch()


def extract(ast, attrib):
    d = {}
    if ast.__class__.__name__ != "Assign":
        return d
    if ast.value.__class__.__name__ == "List":
        # FIXME: Need to handle this the proper way.
        # Not sure what to do with this one yet.
        return d
    for kw in ast.value.keywords:
        if kw.arg != attrib:
            continue
        # If we ever encounter a new Type, uncomment the lines below to debug
        if kw.value.__class__.__name__ == 'List':
            __import__('pdb').set_trace()
        klass = kw.value.__class__.__name__
        d[ast.targets[0].id] = DCA_AST_MAP[klass](kw)
    return d


def process(model, attrib):
    d = {}
    ast = parse(getsource(model))
    ast = ast.body[0]
    for sub_ast in ast.body:
        d.update(extract(sub_ast, attrib))
    return d


def get_inflections(model_name):
    return dict(
        model_name=model_name,
        model_name_lower=model_name.lower(),
        model_name_plural=plural(model_name),
        model_name_lower_plural=plural(model_name.lower()),
    )


def hacky_m2one_name(field):
    '''
    This is a Hacky, Hacky method to get name.
    field.related_model.__class__.__name__ somehow returns `BaseModel`
    which is not somethig we want
    '''
    return str(field.related_model).split(".")[-1].split("'")[0]


def process_model(model):
    fields = {}
    many_fields = {}
    foriegn_keys = []
    choices = process(model, 'choices')
    defaults = process(model, 'default')
    inflections = get_inflections(model.__name__)
    for field in model._meta.get_fields():
        f_name = field.__class__.__name__
        if f_name == 'ManyToOneRel':
            many_fields[field.name] = hacky_m2one_name(field)
        elif f_name == 'ForeignKey':
            name = f'{field.name}_id'
            fields[name] = f_name
            foriegn_keys.append(name)
        else:
            fields[field.name] = f_name
    return dict(
        choices=choices, fields=fields, defaults=defaults,
        inflections=inflections, foriegn_keys=foriegn_keys,
        many_fields=many_fields)


def process_app(app):
    models = {}
    for model in app.get_models():
        models[model.__name__] = process_model(model)
    return models


def process_apps():
    app_models = {}
    for app in apps.get_app_configs():
        if app.name in settings.DCA_APPS:
            models = process_app(app)
            if len(models.keys()) != 0:
                app_models[app.name] = models
    return app_models


def generate_model(model_name, model):
    fields = model['fields']
    choices = model['choices']
    many_fields = model['many_fields']
    # Every model will have an ID
    fields_declaration = '    string id = 1;'
    field_names = list(fields.keys()) + list(many_fields.keys())

    # remove id which is already in declaration
    if 'id' in field_names:
        field_names.remove('id')
    for idx, field in enumerate(sorted(field_names)):
        fields_declaration += f'\n    {field_type} {field} = {idx + 2};'
    defnition = '\nmessage %s {\n%s\n}\n' % (
        model_name, fields_declaration)
    return defnition


def generate_app(app, models):
    app_defnition = ''
    for model_name, model in models.items():
        app_defnition += generate_model(model_name, model)
    return app_defnition


def sluggify(app):
    return re.sub('[^0-9a-zA-Z]+', '_', app)


def write_to_file(app, kind, content, extention='py'):
    app = get_app_name(app)
    comment_prefix = '//'
    if extention in ['py']:
        comment_prefix = '#'
    with open(f"{DCA_DIR}/{app}/dbapi.{extention}", "w") as f:
        print(f'writing to {f.name} ...')
        f.write(f'{comment_prefix} DO NOT EDIT THIS FILE MANUALLY\n')
        f.write(f'{comment_prefix} THIS FILE IS AUTO-GENERATED\n')
        f.write(f'{comment_prefix} MANUAL CHANGES WILL BE DISCARDED\n')
        f.write(f'{comment_prefix} PLEASE READ DCA DOCS\n')
        f.write(content.strip())


def codify_model(app, model_name, model_defnition):
    fields = sorted(model_defnition['fields'].keys())
    foriegn_keys = sorted(model_defnition['foriegn_keys'])
    for field in DCA_REMOVE_FIELDS:
        fields.remove(field)
    ctx = dict(
        app=app, app_slug=sluggify(app), fields=fields, DCA_DIR=DCA_DIR,
        foriegn_keys=foriegn_keys, ignore_fields=DCA_IGNORE_FIELDS)
    ctx.update(model_defnition['inflections'])
    return DCA_CRUD_TEMPLATE % ctx


def codify_app(app, models):
    crud_contents = ''
    for model in models.keys():
        crud_content = codify_model(app, model, models[model])
        crud_contents += crud_content
    write_to_file(app, 'crud', crud_contents)


def generate_code(app_models):
    for app in app_models.keys():
        codify_app(app, app_models[app])

def get_app_name(name):
    """This is another hacky meothod to get app name
        ex. from sample.core to core"""
    
    return name.split('.')[1]


class Command(BaseCommand):
    help = 'Generate crud files'

    def handle(self, *args, **options):
        ensure_data()
        app_models = process_apps()
        generate_code(app_models)